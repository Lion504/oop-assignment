<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/assignemnt-5.1/src/main/java/Task1.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/assignemnt-5.1/src/main/java/Task1.java" />
              <option name="originalContent" value="import java.util.concurrent.locks.Condition;&#10;import java.util.concurrent.locks.Lock;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;public class Task1 {&#10;    // Multi-threaded Number Printing&#10;    private final Lock lock = new ReentrantLock();&#10;    //#volatile ensures visibility of changes to variables across threads&#10;    private volatile int currentNumCheck = 1;&#10;    //#Condition variables to signal threads when it's their turn&#10;    private Condition oddTurn = lock.newCondition();&#10;    private Condition evenTurn = lock.newCondition();&#10;&#10;    class OddThread extends Thread {&#10;       //@max is the upper limit for printing numbers&#10;        private int max;&#10;        OddThread(int max){&#10;            this.max = max;&#10;        }&#10;        //main logic for odd number printing&#10;        @Override&#10;        public void run() {&#10;            //use while instead of if to avoid spurious wakeup&#10;            while(true){&#10;                //acquire the lock before checking/modifying shared state&#10;                lock.lock();&#10;                try{&#10;                    //#currentNumCheck &lt;= max ensures we don't exceed the max value passed into the thread&#10;                    while(currentNumCheck % 2 == 0 &amp;&amp; currentNumCheck &lt;= max){&#10;                        //await releases the lock and waits until signaled&#10;                        oddTurn.await();&#10;                    }&#10;                    if (currentNumCheck &gt; max) {&#10;                        //signal even thread to exit if waiting&#10;                        evenTurn.signal(); //signal even thread to exit if waiting&#10;                        break;&#10;                    }&#10;                    System.out.println(&quot;⚪ &quot; + currentNumCheck + &quot; from Odd Thread&quot;);&#10;                    currentNumCheck++;&#10;                    evenTurn.signal(); //signal even thread to proceed&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt(); //restore interrupt status&#10;                } finally {&#10;                    lock.unlock(); //always unlock in the finally block&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    class EvenThread extends Thread {&#10;        private int max;&#10;        EvenThread(int max){&#10;            this.max = max;&#10;        }&#10;        @Override&#10;        public void run() {&#10;            while(true){&#10;                lock.lock();&#10;                try{&#10;                    while(currentNumCheck % 2 != 0 &amp;&amp; currentNumCheck &lt;= max){&#10;                        evenTurn.await();&#10;                    }&#10;                    if (currentNumCheck &gt; max) {&#10;                        oddTurn.signal(); //signal odd thread to exit if waiting&#10;                        break;&#10;                    }&#10;                    System.out.println(&quot; &quot; +currentNumCheck + &quot; from Even Thread&quot;);&#10;                    currentNumCheck++;&#10;                    oddTurn.signal(); //signal odd thread to proceed&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt(); //restore interrupt status&#10;                } finally {&#10;                    lock.unlock();&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public void startPrinting(int max) {&#10;        //create instances of both threads&#10;        Thread oddThread = new OddThread(max);&#10;        Thread evenThread = new EvenThread(max);&#10;        //start both threads&#10;        oddThread.start();&#10;        evenThread.start();&#10;    }&#10;    public static void main(String[] args) {&#10;        //start printing numbers up to 50&#10;        new Task1().startPrinting(50);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.util.concurrent.locks.Condition;&#10;import java.util.concurrent.locks.Lock;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;public class Task1 {&#10;    // Multi-threaded Number Printing with Enhanced Thread Safety&#10;    private final Lock lock = new ReentrantLock();&#10;    // volatile ensures visibility of changes to variables across threads&#10;    private volatile int currentNum = 1;&#10;    private volatile boolean isPrintingComplete = false;&#10;    // Condition variables to signal threads when it's their turn&#10;    private final Condition oddTurn = lock.newCondition();&#10;    private final Condition evenTurn = lock.newCondition();&#10;&#10;    class OddThread extends Thread {&#10;        // max is the upper limit for printing numbers&#10;        private final int max;&#10;        &#10;        OddThread(int max) {&#10;            this.max = max;&#10;            this.setName(&quot;OddThread&quot;); // Better thread identification&#10;        }&#10;        &#10;        // Main logic for odd number printing&#10;        @Override&#10;        public void run() {&#10;            while (!isPrintingComplete) {&#10;                lock.lock();&#10;                try {&#10;                    // Wait while it's not our turn and printing isn't complete&#10;                    while ((currentNum % 2 == 0 || currentNum &gt; max) &amp;&amp; !isPrintingComplete) {&#10;                        if (currentNum &gt; max) {&#10;                            isPrintingComplete = true;&#10;                            evenTurn.signalAll(); // Wake up even thread to exit&#10;                            break;&#10;                        }&#10;                        oddTurn.await();&#10;                    }&#10;                    &#10;                    if (!isPrintingComplete &amp;&amp; currentNum &lt;= max &amp;&amp; currentNum % 2 == 1) {&#10;                        System.out.println(&quot;⚪ &quot; + currentNum + &quot; from &quot; + Thread.currentThread().getName());&#10;                        currentNum++;&#10;                        evenTurn.signal(); // Signal even thread to proceed&#10;                    }&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt(); // Restore interrupt status&#10;                    break; // Exit gracefully on interruption&#10;                } finally {&#10;                    lock.unlock(); // Always unlock in the finally block&#10;                }&#10;            }&#10;            System.out.println(Thread.currentThread().getName() + &quot; finished execution&quot;);&#10;        }&#10;    }&#10;&#10;    class EvenThread extends Thread {&#10;        private final int max;&#10;        &#10;        EvenThread(int max) {&#10;            this.max = max;&#10;            this.setName(&quot;EvenThread&quot;); // Better thread identification&#10;        }&#10;        &#10;        @Override&#10;        public void run() {&#10;            while (!isPrintingComplete) {&#10;                lock.lock();&#10;                try {&#10;                    // Wait while it's not our turn and printing isn't complete&#10;                    while ((currentNum % 2 != 0 || currentNum &gt; max) &amp;&amp; !isPrintingComplete) {&#10;                        if (currentNum &gt; max) {&#10;                            isPrintingComplete = true;&#10;                            oddTurn.signalAll(); // Wake up odd thread to exit&#10;                            break;&#10;                        }&#10;                        evenTurn.await();&#10;                    }&#10;                    &#10;                    if (!isPrintingComplete &amp;&amp; currentNum &lt;= max &amp;&amp; currentNum % 2 == 0) {&#10;                        System.out.println(&quot; &quot; + currentNum + &quot; from &quot; + Thread.currentThread().getName());&#10;                        currentNum++;&#10;                        oddTurn.signal(); // Signal odd thread to proceed&#10;                    }&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt(); // Restore interrupt status&#10;                    break; // Exit gracefully on interruption&#10;                } finally {&#10;                    lock.unlock();&#10;                }&#10;            }&#10;            System.out.println(Thread.currentThread().getName() + &quot; finished execution&quot;);&#10;        }&#10;    }&#10;&#10;    public void startPrinting(int max) throws InterruptedException {&#10;        System.out.println(&quot;Starting multi-threaded number printing from 1 to &quot; + max);&#10;        &#10;        // Create instances of both threads&#10;        Thread oddThread = new OddThread(max);&#10;        Thread evenThread = new EvenThread(max);&#10;        &#10;        // Start both threads&#10;        oddThread.start();&#10;        evenThread.start();&#10;        &#10;        // Wait for both threads to complete (proper thread management)&#10;        oddThread.join();&#10;        evenThread.join();&#10;        &#10;        System.out.println(&quot;All threads completed successfully!&quot;);&#10;    }&#10;    &#10;    // Reset method for reusing the same instance&#10;    public void reset() {&#10;        currentNum = 1;&#10;        isPrintingComplete = false;&#10;    }&#10;    &#10;    public static void main(String[] args) {&#10;        try {&#10;            Task1 printer = new Task1();&#10;            // Start printing numbers up to 20 for better readability in output&#10;            printer.startPrinting(20);&#10;            &#10;            // Demonstrate reset functionality&#10;            System.out.println(&quot;\n--- Resetting and printing again ---\n&quot;);&#10;            printer.reset();&#10;            printer.startPrinting(10);&#10;            &#10;        } catch (InterruptedException e) {&#10;            System.err.println(&quot;Main thread was interrupted: &quot; + e.getMessage());&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>