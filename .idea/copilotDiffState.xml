<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/assignment-5.2/src/main/java/Task2.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/assignment-5.2/src/main/java/Task2.java" />
              <option name="originalContent" value="import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.LinkedBlockingQueue;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.ThreadLocalRandom;&#10;&#10;/**&#10; * ThreadSafeList: a simple thread-safe wrapper around ArrayList providing&#10; * add, remove, and size operations. Uses synchronized blocks on the backing list to ensure mutual exclusion.&#10; */&#10;class ThreadSafeList&lt;T&gt; {&#10;    private final List&lt;T&gt; list = new ArrayList&lt;&gt;();&#10;&#10;    // Adds an element to the list. Returns true on success.&#10;    public boolean add(T element) {&#10;        synchronized (list) {&#10;            return list.add(element);&#10;        }&#10;    }&#10;&#10;    // Removes a single occurrence of the element from the list. Returns true if removed.&#10;    public boolean remove(T element) {&#10;        synchronized (list) {&#10;            return list.remove(element);&#10;        }&#10;    }&#10;&#10;    // Returns current size snapshot&#10;    public int size() {&#10;        synchronized (list) {&#10;            return list.size();&#10;        }&#10;    }&#10;&#10;}&#10;&#10;/**&#10; * Task2: test program for ThreadSafeList&#10; * - Spawns multiple adder threads which add unique items to the ThreadSafeList and&#10; *   then queue the item id onto a BlockingQueue.&#10; * - Spawns multiple remover threads that take items from the BlockingQueue and&#10; *   remove the corresponding element from the ThreadSafeList.&#10; * - At the end we check the consistency: final size should be zero and removedCount == addedCount.&#10; */&#10;public class Task2 {&#10;    public static void main(String[] args) throws Exception {&#10;        final ThreadSafeList&lt;String&gt; safeList = new ThreadSafeList&lt;&gt;();&#10;        final BlockingQueue&lt;String&gt; addedQueue = new LinkedBlockingQueue&lt;&gt;();&#10;&#10;       final int numAdders = 5, itemsPerAdder = 200, numRemovers = 5, totalAdds = numAdders * itemsPerAdder;&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(numAdders + numRemovers);&#10;&#10;        final AtomicInteger addedCount = new AtomicInteger(0);&#10;        final AtomicInteger removedCount = new AtomicInteger(0);&#10;&#10;        // Adder tasks: add to list, then put the id into the queue so removers can remove it&#10;        for (int a = 0; a &lt; numAdders; a++) {&#10;            final int aid = a;&#10;            executor.submit(() -&gt; {&#10;                for (int i = 0; i &lt; itemsPerAdder; i++) {&#10;                    String id = &quot;item-&quot; + aid + &quot;-&quot; + i;&#10;                    boolean added = safeList.add(id);&#10;                    if (added) {&#10;                        addedCount.incrementAndGet();&#10;                        // offer to queue (should not block)&#10;                        addedQueue.offer(id);&#10;                    }&#10;                    // small random sleep to increase interleaving&#10;                    try {&#10;                        Thread.sleep((long) (ThreadLocalRandom.current().nextDouble() * 2));&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        break;&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        // Remover tasks: take known ids from queue and remove from list&#10;        for (int r = 0; r &lt; numRemovers; r++) {&#10;            executor.submit(() -&gt; {&#10;                while (removedCount.get() &lt; totalAdds) {&#10;                    String id;&#10;                    try {&#10;                        // wait up to 500 ms for an element; if none and producers finished, break&#10;                        id = addedQueue.poll(500, TimeUnit.MILLISECONDS);&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        break;&#10;                    }&#10;                    if (id == null) {&#10;                        // check termination&#10;                        if (addedCount.get() &gt;= totalAdds) break;&#10;                        else continue;&#10;                    }&#10;                    boolean removed = safeList.remove(id);&#10;                    if (removed) {&#10;                        removedCount.incrementAndGet();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        executor.shutdown();&#10;        boolean finished = executor.awaitTermination(30, TimeUnit.SECONDS);&#10;        if (!finished) {&#10;            System.err.println(&quot;Executor didn't finish in time, forcing shutdown&quot;);&#10;            executor.shutdownNow();&#10;        }&#10;&#10;        // Validation&#10;        int finalSize = safeList.size();&#10;        int adds = addedCount.get();&#10;        int removes = removedCount.get();&#10;&#10;        System.out.println(&quot;Adds recorded: &quot; + adds);&#10;        System.out.println(&quot;Removes recorded: &quot; + removes);&#10;        System.out.println(&quot;Final list size (snapshot): &quot; + finalSize);&#10;&#10;        if (finalSize == 0 &amp;&amp; adds == removes &amp;&amp; adds == totalAdds) {&#10;            System.out.println(&quot;SUCCESS: ThreadSafeList passed the concurrent add/remove test&quot;);&#10;        } else {&#10;            System.out.println(&quot;Test finished with inconsistencies; inspect output.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.LinkedBlockingQueue;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.concurrent.ThreadLocalRandom;&#10;&#10;/**&#10; * ThreadSafeList: a simple thread-safe wrapper around ArrayList providing&#10; * add, remove, and size operations. Uses synchronized blocks on the backing list to ensure mutual exclusion.&#10; */&#10;class ThreadSafeList&lt;T&gt; {&#10;    private final List&lt;T&gt; list = new ArrayList&lt;&gt;();&#10;&#10;    // Adds an element to the list. Returns true on success.&#10;    public boolean add(T element) {&#10;        synchronized (list) {&#10;            return list.add(element);&#10;        }&#10;    }&#10;&#10;    // Removes a single occurrence of the element from the list. Returns true if removed.&#10;    public boolean remove(T element) {&#10;        synchronized (list) {&#10;            return list.remove(element);&#10;        }&#10;    }&#10;&#10;    // Returns current size snapshot&#10;    public int size() {&#10;        synchronized (list) {&#10;            return list.size();&#10;        }&#10;    }&#10;&#10;}&#10;&#10;/**&#10; * Task2: test program for ThreadSafeList&#10; * - Spawns multiple adder threads which add unique items to the ThreadSafeList and&#10; *   then queue the item id onto a BlockingQueue.&#10; * - Spawns multiple remover threads that take items from the BlockingQueue and&#10; *   remove the corresponding element from the ThreadSafeList.&#10; * - At the end we check the consistency: final size should be zero and removedCount == addedCount.&#10; */&#10;public class Task2 {&#10;    public static void main(String[] args) throws Exception {&#10;        final ThreadSafeList&lt;String&gt; safeList = new ThreadSafeList&lt;&gt;();&#10;        final BlockingQueue&lt;String&gt; addedQueue = new LinkedBlockingQueue&lt;&gt;();&#10;&#10;       final int numAdders = 5, itemsPerAdder = 200, numRemovers = 5, totalAdds = numAdders * itemsPerAdder;&#10;&#10;        ExecutorService executor = Executors.newFixedThreadPool(numAdders + numRemovers);&#10;&#10;        final AtomicInteger addedCount = new AtomicInteger(0);&#10;        final AtomicInteger removedCount = new AtomicInteger(0);&#10;&#10;        // Adder tasks: add to list, then put the id into the queue so removers can remove it&#10;        for (int a = 0; a &lt; numAdders; a++) {&#10;            final int aid = a;&#10;            executor.submit(() -&gt; {&#10;                for (int i = 0; i &lt; itemsPerAdder; i++) {&#10;                    String id = &quot;item-&quot; + aid + &quot;-&quot; + i;&#10;                    boolean added = safeList.add(id);&#10;                    if (added) {&#10;                        addedCount.incrementAndGet();&#10;                        // offer to queue (should not block)&#10;                        addedQueue.offer(id);&#10;                    }&#10;                    // small random sleep to increase interleaving&#10;                    try {&#10;                        Thread.sleep((long) (ThreadLocalRandom.current().nextDouble() * 2));&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        break;&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        // Remover tasks: take known ids from queue and remove from list&#10;        for (int r = 0; r &lt; numRemovers; r++) {&#10;            executor.submit(() -&gt; {&#10;                while (removedCount.get() &lt; totalAdds) {&#10;                    String id;&#10;                    try {&#10;                        // wait up to 500 ms for an element; if none and producers finished, break&#10;                        id = addedQueue.poll(500, TimeUnit.MILLISECONDS);&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        break;&#10;                    }&#10;                    if (id == null) {&#10;                        // check termination&#10;                        if (addedCount.get() &gt;= totalAdds) break;&#10;                        else continue;&#10;                    }&#10;                    boolean removed = safeList.remove(id);&#10;                    if (removed) {&#10;                        removedCount.incrementAndGet();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;&#10;        executor.shutdown();&#10;        boolean finished = executor.awaitTermination(30, TimeUnit.SECONDS);&#10;        if (!finished) {&#10;            System.err.println(&quot;Executor didn't finish in time, forcing shutdown&quot;);&#10;            executor.shutdownNow();&#10;        }&#10;&#10;        // Validation&#10;        int finalSize = safeList.size();&#10;        int adds = addedCount.get();&#10;        int removes = removedCount.get();&#10;&#10;        System.out.println(&quot;Adds recorded: &quot; + adds);&#10;        System.out.println(&quot;Removes recorded: &quot; + removes);&#10;        System.out.println(&quot;Final list size (snapshot): &quot; + finalSize);&#10;&#10;        if (finalSize == 0 &amp;&amp; adds == removes &amp;&amp; adds == totalAdds) {&#10;            System.out.println(&quot;SUCCESS: ThreadSafeList passed the concurrent add/remove test&quot;);&#10;        } else {&#10;            System.out.println(&quot;Test finished with inconsistencies; inspect output.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/assignment-5.2/src/main/java/test1.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/assignment-5.2/src/main/java/test1.java" />
              <option name="originalContent" value="import java.util.Arrays;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.Callable;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.ThreadLocalRandom;&#10;&#10;public class test1 {&#10;    private static final int TOTAL_SEATS = 16;&#10;    private static final boolean[] seats = new boolean[TOTAL_SEATS]; // false = free, true = reserved&#10;    private static int reservedSeats = 0;&#10;&#10;    // Collects messages from threads in occurrence order; printed after threads finish to avoid interleaving&#10;    private static final List&lt;String&gt; events = Collections.synchronizedList(new ArrayList&lt;&gt;());&#10;&#10;    // Make decision and message collection atomic: check available, record reason, and allocate while holding the lock&#10;    public static synchronized int[] reserveSeatsForCustomer(int requested, int customerId) {&#10;        int available = TOTAL_SEATS - reservedSeats;&#10;        if (available == 0) {&#10;            events.add(&quot;Customer-&quot; + customerId + &quot;: No seats left.&quot;);&#10;            return null;&#10;        }&#10;        if (requested &gt; available) {&#10;            // Not enough for this request now, but some seats remain&#10;            events.add(&quot;Customer-&quot; + customerId + &quot;: Failed to buy &quot; + requested + &quot; tickets (available=&quot; + available + &quot;), retrying...&quot;);&#10;            return null;&#10;        }&#10;        // enough seats -&gt; allocate inline&#10;        int[] allocated = new int[requested];&#10;        int idx = 0;&#10;        for (int i = 0; i &lt; TOTAL_SEATS &amp;&amp; idx &lt; requested; i++) {&#10;            if (!seats[i]) {&#10;                seats[i] = true;&#10;                allocated[idx++] = i;&#10;            }&#10;        }&#10;        reservedSeats += requested;&#10;        events.add(&quot;Customer-&quot; + customerId + &quot;: reserved &quot; + requested + &quot; seat(s): &quot; + Arrays.toString(allocated));&#10;        return allocated;&#10;    }&#10;&#10;    public static synchronized int getAvailableSeats() {&#10;        return TOTAL_SEATS - reservedSeats;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int numCustomers = 20; // more customers than seats&#10;&#10;        // Use a fixed thread pool sized to available processors (but at most numCustomers)&#10;        int nThreads = Math.min(Runtime.getRuntime().availableProcessors(), numCustomers);&#10;        ExecutorService executor = Executors.newFixedThreadPool(Math.max(1, nThreads));&#10;&#10;        List&lt;Callable&lt;Void&gt;&gt; tasks = new ArrayList&lt;&gt;();&#10;&#10;        for (int i = 0; i &lt; numCustomers; i++) {&#10;            final int id = i + 1;&#10;            tasks.add(() -&gt; {&#10;                int attempts = 0;&#10;                int maxAttempts = 3;&#10;&#10;                while (attempts &lt; maxAttempts &amp;&amp; !Thread.currentThread().isInterrupted()) {&#10;                    int request = ThreadLocalRandom.current().nextInt(1, 5); // random request between 1 and 4 seats&#10;&#10;                    // try to reserve (atomic allocate+record)&#10;                    int[] allocated = reserveSeatsForCustomer(request, id);&#10;                    if (allocated != null) {&#10;                        break; // success&#10;                    }&#10;&#10;                    // if there are no seats left the reserveSeatsForCustomer already recorded it&#10;                    if (getAvailableSeats() == 0) {&#10;                        break; // no seats left, stop attempting&#10;                    }&#10;&#10;                    attempts++;&#10;                    // small randomized backoff&#10;                    try {&#10;                        Thread.sleep(50 + ThreadLocalRandom.current().nextInt(100));&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return null;&#10;                    }&#10;                }&#10;&#10;                if (attempts &gt;= maxAttempts) {&#10;                    events.add(&quot;Customer-&quot; + id + &quot;: Giving up after &quot; + attempts + &quot; attempts.&quot;);&#10;                }&#10;                return null;&#10;            });&#10;        }&#10;&#10;        try {&#10;            // invoke all tasks; submit them to executor&#10;            for (Callable&lt;Void&gt; task : tasks) executor.submit(task);&#10;        } finally {&#10;            executor.shutdown(); // no new tasks&#10;            try {&#10;                if (!executor.awaitTermination(3, TimeUnit.SECONDS)) {&#10;                    executor.shutdownNow();&#10;                    if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {&#10;                        events.add(&quot;Executor did not terminate cleanly&quot;);&#10;                    }&#10;                }&#10;            } catch (InterruptedException e) {&#10;                executor.shutdownNow();&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;&#10;        // Print collected events in occurrence order so output is deterministic&#10;        synchronized (events) {&#10;            for (String e : events) System.out.println(e);&#10;        }&#10;&#10;        // Print final seat map&#10;        System.out.println(&quot;\nFinal seat assignments (index 0..&quot; + (TOTAL_SEATS - 1) + &quot;): &quot;);&#10;        for (int i = 0; i &lt; TOTAL_SEATS; i++) {&#10;            System.out.println(&quot;Seat &quot; + i + &quot;: &quot; + (seats[i] ? &quot;RESERVED&quot; : &quot;FREE&quot;));&#10;        }&#10;        System.out.println(&quot;Total reserved seats: &quot; + reservedSeats + &quot; / &quot; + TOTAL_SEATS);&#10;    }&#10;}" />
              <option name="updatedContent" value="import java.util.Arrays;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.Callable;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.ThreadLocalRandom;&#10;&#10;public class test1 {&#10;    private static final int TOTAL_SEATS = 16;&#10;    private static final boolean[] seats = new boolean[TOTAL_SEATS]; // false = free, true = reserved&#10;    private static int reservedSeats = 0;&#10;&#10;    // Collects messages from threads in occurrence order; printed after threads finish to avoid interleaving&#10;    private static final List&lt;String&gt; events = Collections.synchronizedList(new ArrayList&lt;&gt;());&#10;&#10;    // Make decision and message collection atomic: check available, record reason, and allocate while holding the lock&#10;    public static synchronized int[] reserveSeatsForCustomer(int requested, int customerId) {&#10;        int available = TOTAL_SEATS - reservedSeats;&#10;        if (available == 0) {&#10;            events.add(&quot;Customer-&quot; + customerId + &quot;: No seats left.&quot;);&#10;            return null;&#10;        }&#10;        if (requested &gt; available) {&#10;            // Not enough for this request now, but some seats remain&#10;            events.add(&quot;Customer-&quot; + customerId + &quot;: Failed to buy &quot; + requested + &quot; tickets (available=&quot; + available + &quot;), retrying...&quot;);&#10;            return null;&#10;        }&#10;        // enough seats -&gt; allocate inline&#10;        int[] allocated = new int[requested];&#10;        int idx = 0;&#10;        for (int i = 0; i &lt; TOTAL_SEATS &amp;&amp; idx &lt; requested; i++) {&#10;            if (!seats[i]) {&#10;                seats[i] = true;&#10;                allocated[idx++] = i;&#10;            }&#10;        }&#10;        reservedSeats += requested;&#10;        events.add(&quot;Customer-&quot; + customerId + &quot;: reserved &quot; + requested + &quot; seat(s): &quot; + Arrays.toString(allocated));&#10;        return allocated;&#10;    }&#10;&#10;    public static synchronized int getAvailableSeats() {&#10;        return TOTAL_SEATS - reservedSeats;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int numCustomers = 20; // more customers than seats&#10;&#10;        // Use a fixed thread pool sized to available processors (but at most numCustomers)&#10;        int nThreads = Math.min(Runtime.getRuntime().availableProcessors(), numCustomers);&#10;        ExecutorService executor = Executors.newFixedThreadPool(Math.max(1, nThreads));&#10;&#10;        List&lt;Callable&lt;Void&gt;&gt; tasks = new ArrayList&lt;&gt;();&#10;&#10;        for (int i = 0; i &lt; numCustomers; i++) {&#10;            final int id = i + 1;&#10;            tasks.add(() -&gt; {&#10;                int attempts = 0;&#10;                int maxAttempts = 3;&#10;&#10;                while (attempts &lt; maxAttempts &amp;&amp; !Thread.currentThread().isInterrupted()) {&#10;                    int request = ThreadLocalRandom.current().nextInt(1, 5); // random request between 1 and 4 seats&#10;&#10;                    // try to reserve (atomic allocate+record)&#10;                    int[] allocated = reserveSeatsForCustomer(request, id);&#10;                    if (allocated != null) {&#10;                        break; // success&#10;                    }&#10;&#10;                    // if there are no seats left the reserveSeatsForCustomer already recorded it&#10;                    if (getAvailableSeats() == 0) {&#10;                        break; // no seats left, stop attempting&#10;                    }&#10;&#10;                    attempts++;&#10;                    // small randomized backoff&#10;                    try {&#10;                        Thread.sleep(50 + ThreadLocalRandom.current().nextInt(100));&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return null;&#10;                    }&#10;                }&#10;&#10;                if (attempts &gt;= maxAttempts) {&#10;                    events.add(&quot;Customer-&quot; + id + &quot;: Giving up after &quot; + attempts + &quot; attempts.&quot;);&#10;                }&#10;                return null;&#10;            });&#10;        }&#10;&#10;        try {&#10;            // invoke all tasks; submit them to executor&#10;            for (Callable&lt;Void&gt; task : tasks) executor.submit(task);&#10;        } finally {&#10;            executor.shutdown(); // no new tasks&#10;            try {&#10;                if (!executor.awaitTermination(3, TimeUnit.SECONDS)) {&#10;                    executor.shutdownNow();&#10;                    if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {&#10;                        events.add(&quot;Executor did not terminate cleanly&quot;);&#10;                    }&#10;                }&#10;            } catch (InterruptedException e) {&#10;                executor.shutdownNow();&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;&#10;        // Print collected events in occurrence order so output is deterministic&#10;        synchronized (events) {&#10;            for (String e : events) System.out.println(e);&#10;        }&#10;&#10;        // Print final seat map&#10;        System.out.println(&quot;\nFinal seat assignments (index 0..&quot; + (TOTAL_SEATS - 1) + &quot;): &quot;);&#10;        for (int i = 0; i &lt; TOTAL_SEATS; i++) {&#10;            System.out.println(&quot;Seat &quot; + i + &quot;: &quot; + (seats[i] ? &quot;RESERVED&quot; : &quot;FREE&quot;));&#10;        }&#10;        System.out.println(&quot;Total reserved seats: &quot; + reservedSeats + &quot; / &quot; + TOTAL_SEATS);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>